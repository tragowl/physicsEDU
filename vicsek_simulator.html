<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>비첵 모델: 생명체 군집 거동 모사</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
            }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Jua&family=Pretendard:wght@400;600;800&display=swap');
        body { background-color: #0f172a; font-family: 'Pretendard', sans-serif; color: #f1f5f9; overflow-x: hidden; }
        h1, h2 { font-family: 'Jua', sans-serif; }
        .control-panel { background: rgba(30, 41, 59, 0.9); backdrop-filter: blur(10px); }
        input[type=range] { accent-color: #3b82f6; cursor: pointer; }
        canvas { background-color: #020617; border-radius: 1.5rem; box-shadow: 0 0 50px rgba(0,0,0,0.8); width: 100%; }
        .info-card { background: rgba(30, 41, 59, 0.5); border-top: 4px solid #3b82f6; transition: transform 0.2s; }
        .info-card:hover { transform: translateY(-5px); }
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #0f172a; }
        ::-webkit-scrollbar-thumb { background: #334155; border-radius: 4px; }
    </style>
</head>
<body class="min-h-screen p-4 md:p-8">

    <div class="max-w-6xl mx-auto space-y-8">
        <header class="flex flex-col md:flex-row justify-between items-end gap-4">
            <div>
                <h1 class="text-4xl text-blue-400 mb-2">비첵 모델 (Vicsek Model)</h1>
                <p class="text-slate-400">Emergent Behavior in Active Matter Systems</p>
            </div>
            <div class="bg-black/40 backdrop-blur px-6 py-3 rounded-2xl border border-white/10 text-center">
                <div class="text-[10px] text-slate-400 uppercase tracking-widest mb-1">Order Parameter (질서도)</div>
                <div id="orderParam" class="text-3xl font-bold text-blue-400 font-mono">0.00</div>
            </div>
        </header>

        <div class="relative group">
            <canvas id="vicsekCanvas" class="aspect-[16/10] md:aspect-[21/11]"></canvas>
            <div class="absolute bottom-4 left-4 flex gap-2 opacity-0 group-hover:opacity-100 transition-opacity">
                <span class="bg-black/60 text-[10px] px-2 py-1 rounded border border-white/10 uppercase">Active Matter Simulation Field</span>
            </div>
        </div>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
            <div class="lg:col-span-1 space-y-4">
                <div class="control-panel p-6 rounded-3xl border border-slate-700 space-y-6">
                    <h2 class="text-xl text-slate-200 flex items-center gap-2">⚙️ 시뮬레이션 파라미터 조정</h2>
                    
                    <div class="space-y-4">
                        <div>
                            <div class="flex justify-between text-sm mb-2"><span>노이즈 수준 ($\eta$)</span><span id="noiseVal" class="text-blue-400 font-mono">0.10</span></div>
                            <input type="range" id="noiseInput" min="0" max="5" step="0.01" value="0.1" class="w-full">
                        </div>
                        <div>
                            <div class="flex justify-between text-sm mb-2"><span>상호작용 반경 ($R$)</span><span id="radiusVal" class="text-blue-400 font-mono">30</span></div>
                            <input type="range" id="radiusInput" min="5" max="150" step="1" value="30" class="w-full">
                        </div>
                        <div class="pt-2 border-t border-slate-700">
                            <div class="flex justify-between text-sm mb-2 font-bold text-orange-300"><span>최소 배격 거리 ($d_{min}$)</span><span id="sepVal" class="text-orange-400 font-mono">10</span></div>
                            <input type="range" id="sepInput" min="0" max="50" step="1" value="10" class="w-full">
                        </div>
                        <div>
                            <div class="flex justify-between text-sm mb-2"><span>이동 속도 ($v$)</span><span id="speedVal" class="text-blue-400 font-mono">2.0</span></div>
                            <input type="range" id="speedInput" min="0.5" max="10" step="0.1" value="2" class="w-full">
                        </div>
                        <div>
                            <div class="flex justify-between text-sm mb-2"><span>개체 수 ($N$)</span><span id="countVal" class="text-blue-400 font-mono">400</span></div>
                            <input type="range" id="countInput" min="50" max="1500" step="50" value="400" class="w-full">
                        </div>
                    </div>

                    <div class="flex gap-3 pt-2">
                        <button id="resetBtn" class="flex-1 bg-slate-700 hover:bg-slate-600 py-3 rounded-xl font-bold transition">초기화</button>
                        <button id="pauseBtn" class="flex-1 bg-blue-600 hover:bg-blue-500 py-3 rounded-xl font-bold transition">일시정지</button>
                    </div>
                </div>
            </div>

            <div class="lg:col-span-2 grid grid-cols-1 md:grid-cols-2 gap-4 h-full">
                <div class="info-card p-6 rounded-3xl flex flex-col border-t-blue-500">
                    <h2 class="text-lg text-blue-300 mb-3 font-bold">비첵 모델의 기본 원리</h2>
                    <p class="text-sm text-slate-300 leading-relaxed mb-4">
                        비첵 모델은 각 입자가 이웃의 평균 방향을 따르도록 설계되었습니다. 시간 $t+1$에서의 입자 $i$의 방향 $\theta$는 다음과 같이 정의됩니다:
                    </p>
                    <div class="p-3 bg-black/30 rounded-xl font-mono text-sm text-center border border-white/5 mb-2">
                        $\theta_i(t+1) = \langle \theta_j(t) \rangle_{j \in S_i} + \Delta\eta$
                    </div>
                    <p class="text-xs text-slate-400 italic">
                        *여기서 $S_i$는 반경 $R$ 내의 이웃 집합이며, $\Delta\eta$는 무작위 노이즈입니다.
                    </p>
                </div>

                <div class="info-card p-6 rounded-3xl border-t-emerald-500">
                    <h2 class="text-lg text-emerald-300 mb-3 font-bold">생물학적 군집으로의 확장</h2>
                    <p class="text-sm text-slate-300 leading-relaxed">
                        이 모델은 단순한 입자계를 넘어 <strong>새떼, 물고기 떼, 사람의 군집 이동</strong>과 같은 군집의 거동을 모사합니다. 개별 개체의 단순한 규칙이 새로운 집단 질서를 형성하는 과정을 보여줍니다.
                    </p>
                </div>

                <div class="info-card p-6 rounded-3xl border-t-orange-500">
                    <h2 class="text-lg text-orange-300 mb-3 font-bold">모델 수정: 입자간 최소 거리</h2>
                    <p class="text-sm text-slate-300 leading-relaxed mb-2">
                        표준 비첵 모델에서 발생할 수 있는 '무한 중첩'과 '집단 떨림' 현상을 방지하기 위해 <strong>배격성(Separation)</strong> 로직을 추가했습니다. 
                    </p>
                    <ul class="text-xs text-slate-400 list-disc ml-4 space-y-1">
                        <li>입자 간 거리가 $d_{min}$보다 가까워지면 정렬보다 회피 벡터에 우선순위를 둡니다.</li>
                        <li>가중치 기반 조향을 통해 교착 상태(Deadlock)를 해소하고 유연한 흐름을 유지합니다.</li>
                    </ul>
                </div>

                <div class="info-card p-6 rounded-3xl border-t-purple-500">
                    <h2 class="text-lg text-purple-300 mb-2 font-bold">자기조직화와 창발성</h2>
                    <p class="text-sm text-slate-300 leading-relaxed">
                        중앙 통제 없이 개별 입자 간의 국소적 상호작용만으로 전체 계가 하나의 방향성을 갖게 되는 현상을 <strong>자기조직화(Self-Organization)</strong>라고 합니다. 노이즈 수준이 임계값 이하로 떨어질 때 무질서에서 질서로 변하는 <strong>상전이(Phase Transition)</strong> 과정을 관찰할 수 있습니다.
                    </p>
                </div>
            </div>
        </div>

        <footer class="text-center pt-8 border-t border-slate-800 pb-4">
            <p class="text-xs text-slate-500">김현석 물리학 시뮬레이션 시리즈 | Vicsek Model v2.9 (Theoretical Update)</p>
        </footer>
    </div>

    <script>
        const canvas = document.getElementById('vicsekCanvas');
        const ctx = canvas.getContext('2d');
        const orderDisplay = document.getElementById('orderParam');

        const noiseIn = document.getElementById('noiseInput');
        const radiusIn = document.getElementById('radiusInput');
        const sepIn = document.getElementById('sepInput');
        const speedIn = document.getElementById('speedInput');
        const countIn = document.getElementById('countInput');

        let particles = [];
        let config = {
            noise: 0.1,
            radius: 30,
            separation: 10,
            speed: 2,
            count: 400
        };
        let isPaused = false;

        function resize() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = window.innerWidth < 768 ? container.clientWidth * 0.625 : container.clientWidth * 0.52;
            initParticles();
        }

        class Particle {
            constructor() {
                this.init();
            }
            init() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                this.theta = Math.random() * Math.PI * 2;
                this.nextTheta = this.theta;
            }
            update() {
                this.theta = this.nextTheta;
                this.x += Math.cos(this.theta) * config.speed;
                this.y += Math.sin(this.theta) * config.speed;

                if (this.x < 0) this.x += canvas.width;
                if (this.x > canvas.width) this.x -= canvas.width;
                if (this.y < 0) this.y += canvas.height;
                if (this.y > canvas.height) this.y -= canvas.height;
            }
            draw() {
                const size = 5;
                const hue = (this.theta / (Math.PI * 2)) * 360;
                
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.theta);
                
                ctx.beginPath();
                ctx.moveTo(size * 1.5, 0);
                ctx.lineTo(-size, -size * 0.8);
                ctx.lineTo(-size * 0.5, 0);
                ctx.lineTo(-size, size * 0.8);
                ctx.closePath();
                
                ctx.fillStyle = `hsl(${hue}, 80%, 60%)`;
                ctx.fill();
                
                const va = parseFloat(orderDisplay.innerText);
                if (va > 0.85) {
                    ctx.shadowBlur = 8;
                    ctx.shadowColor = `hsl(${hue}, 80%, 60%)`;
                }
                ctx.restore();
            }
        }

        function initParticles() {
            particles = [];
            for (let i = 0; i < config.count; i++) {
                particles.push(new Particle());
            }
        }

        function calculateNextStates() {
            let sumSinAll = 0;
            let sumCosAll = 0;

            for (let i = 0; i < particles.length; i++) {
                const p = particles[i];
                let alignSin = 0;
                let alignCos = 0;
                let alignCount = 0;

                let sepSin = 0;
                let sepCos = 0;
                let sepCount = 0;

                for (let j = 0; j < particles.length; j++) {
                    if (i === j) continue;
                    const other = particles[j];
                    
                    let dx = other.x - p.x;
                    let dy = other.y - p.y;
                    
                    if (dx > canvas.width / 2) dx -= canvas.width;
                    if (dx < -canvas.width / 2) dx += canvas.width;
                    if (dy > canvas.height / 2) dy -= canvas.height;
                    if (dy < -canvas.height / 2) dy += canvas.height;
                    
                    const distSq = dx*dx + dy*dy;

                    if (config.separation > 0 && distSq < config.separation * config.separation && distSq > 0) {
                        const dist = Math.sqrt(distSq);
                        sepSin -= (dy / dist);
                        sepCos -= (dx / dist);
                        sepCount++;
                    }

                    if (distSq < config.radius * config.radius) {
                        alignSin += Math.sin(other.theta);
                        alignCos += Math.cos(other.theta);
                        alignCount++;
                    }
                }

                let targetTheta = p.theta;

                if (sepCount > 0) {
                    const sTheta = Math.atan2(sepSin, sepCos);
                    if (alignCount > 0) {
                        const aTheta = Math.atan2(alignSin, alignCos);
                        targetTheta = Math.atan2(
                            Math.sin(sTheta) * 0.7 + Math.sin(aTheta) * 0.3,
                            Math.cos(sTheta) * 0.7 + Math.cos(aTheta) * 0.3
                        );
                    } else {
                        targetTheta = sTheta;
                    }
                    targetTheta += (Math.random() - 0.5) * config.noise * 1.5;
                } else if (alignCount > 0) {
                    const avgTheta = Math.atan2(alignSin / alignCount, alignCos / alignCount);
                    targetTheta = avgTheta + (Math.random() - 0.5) * config.noise;
                } else {
                    targetTheta = p.theta + (Math.random() - 0.5) * config.noise;
                }

                p.nextTheta = targetTheta;
                sumSinAll += Math.sin(p.theta);
                sumCosAll += Math.cos(p.theta);
            }

            const va = Math.sqrt(sumSinAll**2 + sumCosAll**2) / particles.length;
            orderDisplay.innerText = va.toFixed(2);
            
            if (va > 0.8) orderDisplay.className = "text-3xl font-bold text-emerald-400 font-mono";
            else if (va > 0.3) orderDisplay.className = "text-3xl font-bold text-blue-400 font-mono";
            else orderDisplay.className = "text-3xl font-bold text-red-400 font-mono";
        }

        function loop() {
            if (!isPaused) {
                ctx.fillStyle = 'rgba(2, 6, 23, 0.3)'; 
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                calculateNextStates();
                particles.forEach(p => {
                    p.update();
                    p.draw();
                });
            }
            requestAnimationFrame(loop);
        }

        noiseIn.oninput = (e) => {
            config.noise = parseFloat(e.target.value);
            document.getElementById('noiseVal').innerText = config.noise.toFixed(2);
        };
        radiusIn.oninput = (e) => {
            config.radius = parseInt(e.target.value);
            document.getElementById('radiusVal').innerText = config.radius;
        };
        sepIn.oninput = (e) => {
            config.separation = parseInt(e.target.value);
            document.getElementById('sepVal').innerText = config.separation;
        };
        speedIn.oninput = (e) => {
            config.speed = parseFloat(e.target.value);
            document.getElementById('speedVal').innerText = config.speed.toFixed(1);
        };
        countIn.onchange = (e) => {
            config.count = parseInt(e.target.value);
            document.getElementById('countVal').innerText = config.count;
            initParticles();
        };

        document.getElementById('resetBtn').onclick = initParticles;
        document.getElementById('pauseBtn').onclick = (e) => {
            isPaused = !isPaused;
            e.target.innerText = isPaused ? '재개' : '일시정지';
            e.target.classList.toggle('bg-blue-600');
            e.target.classList.toggle('bg-orange-600');
        };

        window.addEventListener('resize', () => {
            const oldWidth = canvas.width;
            const oldHeight = canvas.height;
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = window.innerWidth < 768 ? container.clientWidth * 0.625 : container.clientWidth * 0.52;
            particles.forEach(p => {
                p.x = (p.x / oldWidth) * canvas.width;
                p.y = (p.y / oldHeight) * canvas.height;
            });
        });

        resize();
        requestAnimationFrame(loop);
    </script>
</body>
</html>
